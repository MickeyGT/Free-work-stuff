#include<fstream>
#include<string.h>
#include<ctype.h>
#include<iostream>
#include<algorithm>
#include<map>
#include<unordered_map>
#include<array>
#include<deque>
#include<math.h>
#include<unordered_set>
#include<set>
#include<iomanip>
#include<bitset>
using namespace std;
int n, arb[300300], lazy[140140], v[100100],pozm[300300], i, sumi, sumf, k, start, poz;
//ifstream f("arbint.in");
//ofstream g("arbint.out");
ifstream f("file.in");
ofstream g("file.out");
void update(int nod, int a, int b, int in, int sf, int diff)
{
	if (lazy[nod] != 0)
	{
		arb[nod] += lazy[nod];
		if (a != b)
		{
			lazy[nod << 1] += lazy[nod];
			lazy[(nod << 1) + 1] += lazy[nod];
		}
		lazy[nod] = 0;
	}
	if (a > b || a > sf || b < in)
		return;
	if (a >= in && b <= sf)
	{
		arb[nod] += diff;
		if (a != b)
		{
			lazy[nod << 1] += diff;
			lazy[(nod << 1) + 1] += diff;
		}
		return;
	}
	int mid = (a + b) / 2;
	update(nod << 1, a, mid, in, sf, diff);
	update((nod << 1) + 1, mid + 1, b, in, sf, diff);
	if (arb[nod << 1] <= arb[(nod << 1) + 1])
	{
		arb[nod] = arb[nod << 1];
		pozm[nod] = pozm[nod << 1];
	}
	else
	{
		arb[nod] = arb[(nod << 1) + 1];
		pozm[nod] = pozm[(nod << 1) + 1];
	}
}
void construct(int in, int sf, int curr)
{
	if (in > sf)
		return;
	if (in == sf)
	{
		arb[curr] = v[in];
		pozm[curr] = in;
		return;
	}
	int mid = (in + sf) / 2;
	construct(in, mid, curr << 1);
	construct(mid + 1, sf, (curr << 1) + 1);
	if (arb[curr << 1] <= arb[(curr << 1) + 1])
	{
		arb[curr] = arb[curr << 1];
		pozm[curr] = pozm[curr << 1];
	}
	else
	{
		arb[curr] = arb[(curr << 1) + 1];
		pozm[curr] = pozm[(curr << 1) + 1];
	}
}
int main()
{
	f >> n;
	k = log2(n);
	for (i = 0; i <= k; i++)
		start += 1 << i;
	start++;
	for (i = 1; i <= n; i++)
	{
		f >> v[i];
		sumi += v[i];
	}
	construct(1, n, 1);
	for (k = 1; k <= n; k++)
	{
		update(1, 1, n, 1, pozm[1]-1, k);
		arb[pozm[1] + start-1] = 1 << 20;
		int x = pozm[1] + start-1;
		while (x != 1)
		{
			arb[x + 1] = arb[x + 1] + lazy[x >> 1];
			arb[x] = arb[x] + lazy[x >> 1];
			arb[x >> 1] = min(arb[x], arb[x + 1]);
			x = x >> 1;
		}
		arb[1] = min(arb[2], arb[3]);
	}
	g << sumf - sumi;
	return 0;
}
