#include<fstream>
#include<string.h>
#include<ctype.h>
#include<iostream>
#include<algorithm>
#include<map>
#include<unordered_map>
#include<array>
#include<deque>
#include<math.h>
#include<unordered_set>
#include<set>
#include<iomanip>
#include<bitset>
using namespace std;
int n, arb[300300], lazy[140140], v[100100], i, sumi, sumf, k, start, poz;
//ifstream f("arbint.in");
//ofstream g("arbint.out");
ifstream f("file.in");
ofstream g("file.out");
void update(int nod, int a, int b, int in, int sf, int diff)
{
	if (lazy[nod] != 0)
	{
		arb[nod] += lazy[nod];
		if (a != b)
		{
			lazy[nod << 1] += lazy[nod];
			lazy[(nod << 1) + 1] += lazy[nod];
		}
		lazy[nod] = 0;
	}
	if (a > b || a > sf || b < in)
		return;
	if (a >= in && b <= sf)
	{
		arb[nod] += diff;
		if (a != b)
		{
			lazy[nod << 1] += diff;
			lazy[(nod << 1) + 1] += diff;
		}
		return;
	}
	int mid = (a + b) / 2;
	update(nod << 1, a, mid, in, sf, diff);
	update((nod << 1) + 1, mid + 1, b, in, sf, diff);
	arb[nod] = min(arb[nod << 1], arb[(nod << 1) + 1]);
}


void construct(int in, int sf, int curr)
{
	if (in > sf)
		return;
	if (in == sf)
	{
		arb[curr] = v[in];
		return;
	}
	int mid = (in + sf) / 2;
	construct(in, mid, curr << 1);
	construct(mid + 1, sf, (curr << 1) + 1);
	arb[curr] = min(arb[curr << 1], arb[(curr << 1) + 1]);
}
int getminpoz(int nod, int a, int b)
{
	if (lazy[nod] != 0)
	{
		arb[nod] += lazy[nod];
		if (a != b)
		{
			lazy[nod << 1] += lazy[nod];
			lazy[(nod << 1) + 1] += lazy[nod];
		}
		lazy[nod] = 0;
	}
	if (a == b)
		return nod-start;
	int mid = (a + b) / 2;
	if (arb[nod << 1] < arb[(nod << 1) + 1])
		return getminpoz(nod << 1, a, mid);
	else
		return getminpoz((nod << 1) + 1, mid + 1, b);
}
int main()
{
	f >> n;
	k = log2(n);
	for (i = 0; i <= k; i++)
		start += 1 << i;
	start++;
	for (i = 1; i <= n; i++)
	{
		f >> v[i];
		sumi += v[i];
	}
	construct(1, n, 1);
	for (k = 1; k <= n; k++)
	{
		poz = getminpoz(1, 1, n);
		sumf += v[poz+1];
		update(1, 1, n, 1, poz, k);
		arb[poz+start] = 1 << 20;
		int x = poz+start;
		while (x != 1)
		{
			arb[x + 1] = arb[x + 1] + lazy[x >> 1];
			arb[x] = arb[x] + lazy[x >> 1];
			arb[x >> 1] = min(arb[x], arb[x + 1]);
			x = x >> 1;
		}
		arb[1] = min(arb[2], arb[3]);
	}
	g << sumf - sumi;
	return 0;
}
