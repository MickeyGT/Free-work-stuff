#include<fstream>
#include<string.h>
#include<ctype.h>
#include<iostream>
#include<algorithm>
#include<map>
#include<unordered_map>
#include<array>
#include<deque>
#include<unordered_set>
#include <cstdio>
using namespace std;
struct Graf
{
	int nod, cost;
	Graf *next;
};
int n, m, d[50001], h[50001], poz[50001], k,j,x,y,z;
Graf *a[50001];
void swap(int x, int y)
{
	int t = h[x];
	h[x] = h[y];
	h[y] = t;
}
void add(int where, int what, int cost)
{
	Graf *q = new Graf;
	q->nod = what;
	q->cost = cost;
	q->next = a[where];
	a[where] = q;
}
void upheap(int what)
{
	int tata;
	while (what > 1)
	{
		tata = what >> 1;

		if (d[h[tata]] > d[h[what]])
		{
			poz[h[what]] = tata;
			poz[h[tata]] = what;

			swap(tata, what);

			what = tata;
		}
		else
			what = 1;
	}
}

void downheap(int what)
{
	int f;
	while (what <= k)
	{
		f = what;
		if ((what << 1) <= k)
		{
			f = what << 1;
			if (f + 1 <= k)
				if (d[h[f + 1]] < d[h[f]])
					++f;
		}
		else
			return;

		if (d[h[what]] > d[h[f]])
		{
			poz[h[what]] = f;
			poz[h[f]] = what;

			swap(what, f);

			what = f;
		}
		else
			return;
	}
}

void dijkstra_heap()
{
	for (int i = 2; i <= n; ++i)
		d[i] = 1<<30, poz[i] = -1;
	poz[1] = 1;

	h[++k] = 1;

	while (k)
	{
		int min = h[1];
		swap(1, k);
		poz[h[1]] = 1;
		--k;

		downheap(1);

		Graf *q = a[min];

		while (q)
		{
			if (d[q->nod] > d[min] + q->cost)
			{
				d[q->nod] = d[min] + q->cost;

				if (poz[q->nod] != -1)
					upheap(poz[q->nod]);
				else
				{
					h[++k] = q->nod;
					poz[h[k]] = k;
					upheap(k);
				}
			}
			q = q->next;
		}
	}
}
int main()
{
	ifstream f("file.in");
	ofstream g("file.out");
	f >> n >> m;
	for (j = 1; j <= m; j++)
	{
		f >> x >> y >> z;
		add(x, y, z);
	}
	dijkstra_heap();
	for (j = 2; j <= n; j++)
		if (d[j] != 1 << 30)
			g << d[j] << " ";
		else
			g << "0 ";
	return 0;
}
